<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>模写 - ゲーム</title>
  <link rel="stylesheet" href="style.css">
  <style>
    .split { display:flex; justify-content:center; gap:30px; flex-wrap:wrap; margin:20px 0; }
    .area { border:2px solid #bdc3c7; padding:10px; border-radius:8px; background:white; }
    canvas { border:1px solid #34495e; background:#fff; touch-action:none; }
    .controls button { margin:8px; padding:10px 25px; font-size:1.1rem; border:none; border-radius:6px; cursor:pointer; }
    #clear  { background:#e74c3c; color:white; }
    #finish { background:#3498db; color:white; }
    #home   { background:#7f8c8d; color:white; }
  </style>
</head>
<body>

  <h2 id="title">模写ゲーム</h2>

  <div class="split">
    <div class="area">
      <h3>お題</h3>
      <canvas id="ref" width="380" height="480"></canvas>
    </div>
    <div class="area">
      <h3>ここに描いてください</h3>
      <canvas id="draw" width="380" height="480"></canvas>
    </div>
  </div>

  <div class="controls">
    <button id="clear">クリア</button>
    <button id="finish">完了して判定</button>
    <button id="home">ホームに戻る</button>
  </div>

<script>
// ========== 図形テンプレート（基本形） ==========
const shapeTemplates = {
  circle:   {type: "circle",   r: 110, color: "#000000", lineWidth: 6},
  rect:     {type: "rect",     w: 220, h: 220, color: "#000000", lineWidth: 6},
  triangle: {type: "triangle", size: 180, color: "#000000", lineWidth: 6},
  star:     {type: "star",     r: 100, points: 5, color: "#000000", lineWidth: 6}
};

// 難易度ごとのお題生成関数
function generateShapes(level) {
  const centerX = 190;
  const centerY = 240;
  const shapes = [];

  if (level === "easy") {
    // 初級：1つだけランダム
    const types = ["circle", "rect", "triangle", "star"];
    const randomType = types[Math.floor(Math.random() * types.length)];
    const base = shapeTemplates[randomType];

    // 少しサイズ・位置をランダムに揺らす（自然に見える程度）
    const randScale = 0.9 + Math.random() * 0.2; // 90%〜110%
    const offsetX = (Math.random() - 0.5) * 40;
    const offsetY = (Math.random() - 0.5) * 40;

    shapes.push({
      ...base,
      x: centerX + offsetX,
      y: centerY + offsetY,
      r:     base.r     ? base.r     * randScale : undefined,
      w:     base.w     ? base.w     * randScale : undefined,
      h:     base.h     ? base.h     * randScale : undefined,
      size:  base.size  ? base.size  * randScale : undefined,
      points: base.points ? base.points : undefined,
    });
  } 
  else if (level === "medium") {
    // 中級：2つ（固定パターンだが位置少しランダム）
    const types = ["circle", "rect", "triangle", "star"];
    const t1 = types[Math.floor(Math.random() * types.length)];
    const t2 = types[Math.floor(Math.random() * types.length)];
    
    shapes.push({...shapeTemplates[t1], x: centerX - 20 + Math.random()*40, y: centerY - 30});
    shapes.push({...shapeTemplates[t2], x: centerX + 20 + Math.random()*40, y: centerY + 30});
  } 
  else if (level === "hard") {
    // 上級：3つ
    const types = ["circle", "rect", "triangle", "star"];
    for (let i = 0; i < 3; i++) {
      const t = types[Math.floor(Math.random() * types.length)];
      const offsetX = (Math.random() - 0.5) * 80;
      const offsetY = (Math.random() - 0.5) * 80;
      shapes.push({...shapeTemplates[t], x: centerX + offsetX, y: centerY + offsetY});
    }
  }

  return shapes;
}

// ========== 描画ヘルパー ==========
const refCanvas = document.getElementById("ref");
const drawCanvas = document.getElementById("draw");
const ctxRef  = refCanvas.getContext("2d");
const ctxDraw = drawCanvas.getContext("2d");

function drawCircle(ctx, x, y, r, color, lineWidth) {
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.stroke();
}

function drawRect(ctx, x, y, w, h, color, lineWidth) {
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.strokeRect(x - w/2, y - h/2, w, h);
}

function drawTriangle(ctx, x, y, size, color, lineWidth) {
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.beginPath();
  
  const h = size * Math.sqrt(3) / 2;  // 正三角形の高さ
  
  ctx.moveTo(x,         y - h * 2/3);
  ctx.lineTo(x - size/2, y + h / 3);
  ctx.lineTo(x + size/2, y + h / 3);
  ctx.closePath();
  ctx.stroke();
}

function drawStar(ctx, x, y, r, points, color, lineWidth) {
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.beginPath();
  for (let i = 0; i < points * 2; i++) {
    const angle = (Math.PI / points) * i - Math.PI / 2;
    const radius = (i % 2 === 0) ? r : r * 0.4;
    ctx.lineTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
  }
  ctx.closePath();
  ctx.stroke();
}

function drawShape(ctx, shape) {
  const {type, x, y, color, lineWidth = 6} = shape;
  switch(type) {
    case "circle":   drawCircle  (ctx, x, y, shape.r,     color, lineWidth); break;
    case "rect":     drawRect    (ctx, x, y, shape.w, shape.h, color, lineWidth); break;
    case "triangle": drawTriangle(ctx, x, y, shape.size,  color, lineWidth); break;
    case "star":     drawStar    (ctx, x, y, shape.r, shape.points, color, lineWidth); break;
  }
}

// ========== ゲーム初期化 ==========
const level = localStorage.getItem("level") || "easy";
const levelNames = {easy: "初級", medium: "中級", hard: "上級"};
document.getElementById("title").textContent = `難易度：${levelNames[level]}`;

// お題を生成して描画
const currentShapes = generateShapes(level);
currentShapes.forEach(s => drawShape(ctxRef, s));

// ========== ユーザーの描画（線） ==========
let drawing = false;
let lastX = null;
let lastY = null;

function getPos(e) {
  const rect = drawCanvas.getBoundingClientRect();
  const clientX = e.clientX ?? (e.touches?.[0]?.clientX ?? null);
  const clientY = e.clientY ?? (e.touches?.[0]?.clientY ?? null);
  if (clientX === null || clientY === null) return null;
  return {
    x: clientX - rect.left,
    y: clientY - rect.top
  };
}

function drawLine(e) {
  if (!drawing) return;
  e.preventDefault();
  const pos = getPos(e);
  if (!pos) return;

  ctxDraw.strokeStyle = "#000000";
  ctxDraw.lineWidth = 12;
  ctxDraw.lineCap = "round";
  ctxDraw.lineJoin = "round";

  if (lastX !== null && lastY !== null) {
    ctxDraw.beginPath();
    ctxDraw.moveTo(lastX, lastY);
    ctxDraw.lineTo(pos.x, pos.y);
    ctxDraw.stroke();
  }

  lastX = pos.x;
  lastY = pos.y;
}

function startDrawing(e) {
  drawing = true;
  const pos = getPos(e);
  if (pos) {
    lastX = pos.x;
    lastY = pos.y;
    // 最初の一筆も描く（点にならないように）
    ctxDraw.beginPath();
    ctxDraw.arc(pos.x, pos.y, 6, 0, Math.PI*2);
    ctxDraw.fillStyle = "#000";
    ctxDraw.fill();
  }
}

function stopDrawing() {
  drawing = false;
  lastX = null;
  lastY = null;
}

drawCanvas.addEventListener("mousedown", startDrawing);
drawCanvas.addEventListener("mousemove", drawLine);
drawCanvas.addEventListener("mouseup", stopDrawing);
drawCanvas.addEventListener("mouseout", stopDrawing);

drawCanvas.addEventListener("touchstart", startDrawing);
drawCanvas.addEventListener("touchmove", drawLine);
drawCanvas.addEventListener("touchend", stopDrawing);
drawCanvas.addEventListener("touchcancel", stopDrawing);

// ========== ボタン ==========
document.getElementById("clear").onclick = () => {
  ctxDraw.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
};

document.getElementById("finish").onclick = () => {
  const sim = compareCanvases();
  localStorage.setItem("lastScore", sim);
  window.location.href = "result.html";
};

document.getElementById("home").onclick = () => {
  window.location.href = "index.html";
};

// ========== 一致度計算 ==========

// ========== 改善版：近傍許容 + 難易度別甘さ調整 ==========
function compareCanvases() {
  const w = drawCanvas.width;
  const h = drawCanvas.height;
  const refData  = ctxRef.getImageData(0, 0, w, h).data;
  const drawData = ctxDraw.getImageData(0, 0, w, h).data;
  
  let matched = 0;
  let totalRefPixels = 0;   // お題の線ピクセル数

  const tolerance = 8;      // 許容距離（ピクセル） ← これが大事！
  const levelBonus = {      // 難易度別ボーナス倍率
    easy:   1.5,
    medium: 1.5,
    hard:   1.5
  };
  const bonus = levelBonus[level] || 1.3;

  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const i = (y * w + x) * 4;
      const refA = refData[i + 3];

      if (refA < 40) continue;  // お題の線以外は無視
      totalRefPixels++;

      // このお題ピクセルの近傍（tolerance以内）をチェック
      let found = false;
      for (let dy = -tolerance; dy <= tolerance && !found; dy++) {
        for (let dx = -tolerance; dx <= tolerance && !found; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;

          const ni = (ny * w + nx) * 4;
          const drawA = drawData[ni + 3];
          const drawR = drawData[ni];
          const drawG = drawData[ni + 1];
          const drawB = drawData[ni + 2];

          // 黒に近い & 十分な濃さ
          if (drawA > 100 && drawR < 80 && drawG < 80 && drawB < 80) {
            found = true;
          }
        }
      }

      if (found) {
        matched++;
      }
    }
  }

  if (totalRefPixels === 0) return 0;

  let score = (matched / totalRefPixels) * 100 * bonus;

  // 上限100、最低0
  score = Math.max(0, Math.min(100, Math.round(score)));

  // デバッグ用（コンソールで見たい場合）
  // console.log(`matched: ${matched}, total: ${totalRefPixels}, raw: ${(matched/totalRefPixels*100).toFixed(1)}%, bonus: ${bonus}, final: ${score}%`);

  return score;
}

</script>

</body>
</html>